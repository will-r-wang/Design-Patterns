Course Title: Programming Foundations: Design Patterns

Description: Design patterns are reusable solutions that solve the challenges software developers face over and over again. Rather than reinventing the wheel, learn how to make use of these proven and tested patterns that will make your software more flexible and resilient to change. This course introduces you to design patterns and takes you through several of the most used object-oriented patterns. Elisabeth Robson and Eric Freeman, coauthors of Head First Design Patterns, join forces to provide an overview of each pattern and examples of the pattern in action. Featured design patterns include the Strategy, Adapter, Observer, and Decorator patterns. Elisabeth and Eric lend these concepts a real-world context by providing code demos in Java, with the occasional example in Python and JavaScript.


***********************************************
Chapter: Introduction
***********************************************


-----------------------------------------------
Video: Don't reinvent the wheel
-----------------------------------------------
Object-oriented design experience often doesn't come easy. Even for experienced developers it can take a lot of trial and error to come up with designs that are flexible, extensible, more maintainable, or even just easier to communicate to your teammates. But chances are some developer has already encountered a design challenge similar to yours, and they've come up with a solution and captured it in a design pattern, a design pattern that's well documented and ready for you to use. - Design patterns are general solutions to common object-oriented problems. You can use design patterns to create software that is more flexible, maintainable, and resilient to change. Central to these design patterns are a whole new set of design principles that go beyond the core object-oriented principles. These design principles will help you to avoid problematic designs and help you understand how design patterns work. - Hi, I'm Eric Freeman. - And I'm Elisabeth Robson. We hope you'll join us to learn how to improve your object-oriented skills with design patterns.


-----------------------------------------------
Video: What you should know
-----------------------------------------------
To be successful in this course, you should have experience with a programming language like Java, C#, Python, Swift or another object-oriented language. During the course, we'll be looking at small snippets of code. We've also provided the examples we talk about in this course as complete examples that you can download in the exercise files. There, you'll be able to see the full context of how that code is implemented in Java and how each snippet interacts with the larger body of code. - You'll be using simple, UML style class diagrams to describe each of the patterns and Java to implement the examples. You don't need prior experience with Java but it will be helpful. We've kept examples fairly simple, so you should be able to easily transfer the ideas to your favorite object-oriented programming language. - We won't be using a specific IDE for this course, so if you'd like any additional information on how to compile and run Java code on your own, we'd recommend you take a look at some of the Java courses available like Java Essential Training or Java IDE Overview courses. Both of these courses will get you started with Java if you want to compile and run the examples. - This course builds on the principles of object-oriented programming, but at any point during this course you need a review of inheritance, polyno-rithms, abstraction or encapsulation, take a look at Programming Foundations Object-Oriented Design for a good overview.


***********************************************
Chapter: 1. Design Patterns
***********************************************


-----------------------------------------------
Video: Object-oriented design experience
-----------------------------------------------
Object-oriented design experience doesn't come easy, and it can take a lot of trial and error to come up with designs that are flexible and extensible. We're all taught the importance of the fundamental properties of object-oriented programming, namely inheritance, polymorphism, abstraction, and encapsulation. When these are the only tools in your toolbox, your design process can quickly go off the rails. In fact, it can lead to software that is downright difficult to design, maintain, and extend. - No doubt, you're already familiar with off-the-shelf libraries, modules, and frameworks. This is packaged up code that you compile into your application so that you can benefit from code that other developers have written. Design patterns, on the other hand, give us packaged up design insight and experience. Design patterns provide paths to solutions for some of the most common object-oriented design conundrums. They're solutions developed over time through trial and error that are well-documented and can be applied to your specific design problem. - We like to say design patterns don't go directly into your code. Instead, they first go into your brain. Once you've studied patterns and you have a good working knowledge of them, you can then start to apply them in your own object-oriented designs. In this course, we're going to start to get those patterns into your brain. - Design patterns were first described in the book Design Patterns: Elements of Reusable Object-Oriented Software Design. This book was written by four software engineers affectionately known as the gang of four. In their book, they catalog 23 of these patterns and began a whole new way of thinking about object-oriented design and programming. While the list of design patterns has grown over the last couple of decades these original 23 patterns are still among the most commonly used today. - So what will using design patterns get you? Design patterns will first and foremost help you to not reinvent the wheel. By using patterns, you can often shortcut your design process by leveraging the hard work of other developers who have already gone through a similar exercise and found good solutions that you can use. - [Woman] There's another big advantage to using design patterns. Using patterns will often help you to create software that is resilient to change. That's an important consideration because software requirements are always changing. New features are always being added, and environments are constantly evolving. Design patterns can protect you from the changes and additions you'll need to make in the future. you'll need to make in the future.


-----------------------------------------------
Video: What are design patterns?
-----------------------------------------------
Design patterns are all about reusing experience, design experience. Design patterns aren't algorithms and they're not code. A design pattern is an approach to thinking about software design that incorporates the experience of developers who've had similar problems, as well as fundamental design principles that guide how we structure software designs. A design pattern is usually expressed by a definition and a class diagram and collected into a catalog of patterns. In these catalogs, you'll find example scenarios when a pattern might be applicable. The consequences of using a pattern and even some sample code. As you'll see, patterns are pretty abstract, it's up to you to determine if the pattern is right for your situation and your specific problem. And once you've figured that out, how best to implement it. As you'll see, patterns are pretty abstract, it's up to you to determine if the pattern is right for your situation and your specific problem. And once you've figured that out, how best to implement it. Design patterns are not specific solutions for specific kinds of software. There isn't one design pattern for banking software and a different design pattern for game software, and another pattern for social media software. Rather, design patterns are general solutions for common problems that crop up in all kinds of applications. For instance, you might be working through your class design and discover that if one object changes, several other objects need to know about that change. Is there a way to structure objects so they aren't too tightly dependent on one another? This is the kind of problem that you'll encounter in software systems across all domains. And while there are many different ways that you could solve this problem, there's a proven way to solve it. A best practice called the observer design pattern. We'll be learning more about the observer pattern later. In this course, we'll be focusing on six of the 23 original patterns in the Gang of Four Catalog. These are the patterns you're likely to find most useful because they're approaches to the most common problems that crop up as you design and develop a software system. Once you've learned how to read and understand these six patterns, you'll be able to explore more patterns on your own. You'll find a more complete treatment of the original 23 patterns in our book: Head First Design Patterns: A Brain-Friendly Guide to Design Patterns. We'll describe each pattern conceptually, talk about its object oriented design in the form of a class diagram and then show code snippets to show you the key features of a pattern implemented in code. Our goal is to demonstrate each pattern as simply as possible so that you can apply it to your own problems.


-----------------------------------------------
Video: What are design principles?
-----------------------------------------------
Although this course is about design patterns, you'll also find it beneficial to learn a set of object-oriented design principles. These principles go beyond the object-oriented basics you already know, like inheritance, polymorphism, abstraction, and encapsulation. And these principles really give you a set of guidelines that will help you to avoid bad object-oriented design. These might be designs that are too rigid, inflexible, too fragile, too hard to understand. You might be saying to yourself that sounds a lot like a design pattern, and they do share a common goal, good object-oriented design. But principles and patterns are different. Principles are general guidelines while patterns are specific design solutions often aimed at solving common object-oriented problems. As we see more of each, you'll start to understand the difference. Let's look at one example of an important principle we'll be touching on throughout the course, encapsulate what varies. This principle tells us to look for parts of our code that are frequently changing and to pull out those parts in order to separate them from all the other code that isn't changing. And sometimes code changes with every new set of requirements. The principle doesn't tell us at all how to actually do this. There are a number of ways you could separate the code that varies from the code that stays the same. Instead, principles tell us to strive for a particular quality in our design, and this is often where patterns come in. Design patterns often demonstrate different ways of, for example, separating what varies in our design. We'll see this principle at play in our first pattern, the strategy pattern, which shows us how to separate out an object's behavior. It's algorithm, if you will, in a flexible and extensible way. This also won't be the last you see of the encapsulate what varies principle. This one principle forms the basis for almost every design pattern. Almost all patterns provide a way to let some part of the system vary independently from the other parts. And as you'll see, different patterns do this in different ways depending on the problems they're solving.


***********************************************
Chapter: 2. The Strategy Pattern
***********************************************


-----------------------------------------------
Video: Revisiting inheritance
-----------------------------------------------
Inheritance is one of the core concepts of object-oriented design. Through inheritance, you can express class relationships that allow you to reuse and extend the behavior and properties of other classes. And code reuse is often touted as the main benefit of inheritance in object-oriented design. Typically you think of one class inheriting from another if they share an IS-A relationship. For instance, if a cat is an animal, then a cat should inherit from the animal class. We can extend this further with other types of animals. In each case, we're reusing the implementation of the classes we inherit from. This is a powerful technique, and there are many designs where inheritance is exactly the right choice. While inheritance is a core concept in object-oriented programming, it's also easy to overdo inheritance and make it the basis of all your object-oriented design. It's easy to treat inheritance as a hammer, making every design look like it needs superclasses and subclasses, in other words, your nails. So pay attention. it might be time to take a closer look at your design. Why? Because as we're going to see, when you overuse inheritance, you can end up with designs that are inflexible and difficult to change. and difficult to change.


-----------------------------------------------
Video: Limitations of inheritance
-----------------------------------------------
What we really need at this point is an example to demonstrate the problems with inheritance, so let's take a look at a class design for a duck simulator. Let's say we want to design a duck simulator. To do that we need a set of Duck classes. It would be natural to think that you could start with a Duck superclass. You might give the superclass a quack method and a swim method because those are the things that you'd guess all ducks are going to want to do. Let's also give it a display method. But we'll keep that abstract meaning each subclass will need to implement it because each duck will want to implement its own unique appearance. Now because display is abstract, that makes our duck class abstract too meaning that we cannot instantiate a duck directly. To create a duck, we need some concrete classes. Let's add a concrete class MallardDuck and implement its display method so it looks like a mallard. And we'll also add a redheaded duck and display its display method so it looks like a redheaded duck. So far this looks like a good design, right? Well, let's see. Ask yourself, what happens sooner or later in every object-oriented design? Well, the unexpected of course. Let's say we get a request to add another new duck type, a RubberDuck, simple enough, right? First we'll implement the duck's display method to make it look like a rubber duck. But then we have a slight problem because rubber ducks don't quack. In fact, they usually squeak but we can handle that by overriding the quack method and making the rubber duck squeak. So far our design's holding up pretty well, don't you think? Here's another common occurrence that happens when we develop object-oriented systems. We get a feature request. Let's imagine we get a feature request to make ducks fly. Well, now we can leverage inheritance by adding flying to the base duck superclass and then all ducks will be able to inherit or reuse this behavior. Once we've added a fly method to duck, then MallardDuck and RedheadDuck and oops, the RubberDuck can now fly too but we all know that rubber ducks don't actually fly. We need to fix the RubberDuck again by overriding the fly method. And then we'll add some code to make sure that the RubberDuck does nothing in the method when it's called. Okay, any real duck simulator probably needs to deal with decoy ducks too, so let's see how a decoy duck fits into our design. First, we need a display method and decoy ducks don't quack, so we'll override the quack method with an implementation that's silent. Oh and we'll also need to override fly so that the decoy duck doesn't fly. We're able to make all these additions within the framework of our design but is this really the best design? Let's step back and think about this. Because we're overriding most of the methods now in the superclass, we're not getting a whole lot of benefit from inheritance, at least for some ducks. Let's step through some of the problems in detail. First, while we are keeping ducks organized in a hierarchy of classes, we don't seem to be getting a huge reuse benefits and things are getting a little messy including. Also, we're starting to get code duplicated across the classes. We've got code that keeps ducks from flying. We've got code that keeps ducks from quacking or has them making other types of sounds. And another thing, we can't really look at our superclass and get a whole lot of direct knowledge about the ducks. We have to go into each concrete class to learn more about what the code does. And as we saw with fly, a simple change to the superclass can lead to unintended side effects with the other ducks. Finally, notice that all the ducks' behavior is assigned at compile time and because of this, we can't change a particular duck instance at runtime say to not be able to fly if it's been injured or captured. So, this design isn't providing much flexibility. The flexibility that we might need as the application becomes more sophisticated.


-----------------------------------------------
Video: Trying interfaces
-----------------------------------------------
Now if you're a well-schooled Java developer, you might be saying, hey, let's use interfaces instead. You might remember that an interface defines the methods an object must implement in order to be a particular type. For instance, if a duck implements a flyable interface with one method fly, then duck must implement the method fly to be considered the flyable type. So interfaces allow different classes to share similarities like ducks sharing a fly behavior. Interfaces also allow for having two classes that are alike, but don't have the same behavior, for some ducks being able to fly and some not. So interfaces actually sound perfect for our design. Let's rework our duck interfaces and see how well this works out. We'll begin by creating two interfaces, flyable and quackable, if I'm a duck and I fly, I implement the flyable interface, and if I'm a duck and I quack, I implement the quackable interface. And our duck superclass now just needs a swim method since all ducks do that and also an abstract display method. Mallard and Redhead ducks, they both inherit from duck, and they implement both the flyable and the quackable interfaces. RubberDuck on the other hand just implements quack, it makes a squeak sound but it doesn't fly and DecoyDuck doesn't need to implement either, it just needs a display method. This design looks pretty nice doesn't it? Unfortunately it too is problematic. On paper, this design solves part of our issue, but it also absolutely destroys any possibility of code reuse. Imagine having 20 or 30 or 40 ducks, every single duck will have to implement its own fly and quack methods. Worse, any changes needed to flying or quacking would cause a maintenance nightmare as we'll probably have to look at the code in every one of those classes and make changes. And another thing, we can't easily make runtime changes to our behaviors should we want to, if wanted a duck to start life not being able to fly and then for that duck to acquire the ability to fly midway through the simulation. How would we do that in an elegant way? Let's look at this problem from a slightly different perspective.


-----------------------------------------------
Video: Get inspiration from design principles
-----------------------------------------------
At this point, we really don't have a clear design direction for our duck simulator. Let's step back for a moment and review what we've tried. We started by implementing our ducks with inheritance. Only as the variety of ducks and behaviors increased, we found this didn't support our design very well. In fact, what was appropriate for one concrete subclass like the MallardDuck, wasn't necessarily appropriate for another, like the RubberDuck. This led to code duplication and actually limited our ability to make use of inheritance. We also tried using interfaces but that didn't work very well either. While using interfaces cleaned up our design from an object-oriented perspective, using interfaces totally destroyed our ability to reuse code. In fact, every concrete subclass needed to implement its own flying and quacking behavior. So, where do we go from here? Have we reached some fundamental limit to object-oriented design? Well, not at all. In fact, let's return to the encapsulate what varies design principle for a little inspiration. So, in the previous chapter, we introduced this design principle. Encapsulate what varies. This principles says that if some aspect of your code is changing, for instance, say you find yourself altering the flying and quacking code every time you add a new type of duck, well, that's a strong indication that you need to pull out those parts that are changing and to separate them from the rest of your code. How does that help? Well, think about it like this. Once you separate out the parts that are frequently changing, you can then modify those parts without affecting the rest of your code. As an example, if we can separate out what's varying in our ducks, like their flying and quacking behaviors, then we can isolate all the changes we'll need to make to those behaviors in the future. As we've said, this idea of separating what varies is an idea you're going to see over and over with design patterns and in general with good object-oriented design and each pattern tends to provide a unique way of achieving this. Now let's see if we can apply the encapsulate what varies principles to our duck simulator. To do that, let's check out our class diagram again. Looking at the duck class, we know that quack varies because some ducks quack and some squeak and some make no sound at all and in the future, it seems like there will probably be other ways for ducks to make sound as well. Fly also varies over the subclasses. Some ducks fly and some don't and perhaps in the future, some ducks will fly in other ways. Swim though, swim seems to be consistent across all the ducks. There's no indication of it varying here and while display is implemented in each individual duck, it's really done by design. Okay, so we've identified what varies, namely the flying and quacking. Now what? Well, we need to pull out those behaviors and separate them from the rest of the duck. But how do we do that? Again, we're going to look to a new design principle for inspiration for how to separate the flying and quacking behaviors of the ducks. This new principles says to program to an interface, not an implementation. Remember that an interface is essentially a super type. So, this principle tells us that we should use the super type to refer to objects rather than their specific type. How will this help us with the duck behavior? Well, if we can apply this to our ducks' behavior, it means we won't be tied to a specific implementation of behavior, so we will in theory have more flexibility in how our ducks behave. But didn't we just try to use interfaces and run into problems? We did but it was the way we were using interfaces that caused the problems. We were still relying on the ducks to provide the concrete implementations of flying and quacking. Let's try a different way.


-----------------------------------------------
Video: Programming to an interface
-----------------------------------------------
Let's go back to the original duck design and rethink this from the perspective of separating what varies and programming to an interface. To separate what varies, we're going to move the implementations of quack and fly out of the duck class. We're also going to make sure that we're programming to an interface rather than an implementation by using two interfaces, quack behavior and fly behavior. Now let's use these interfaces by implementing some concrete quacking and flying subclasses. For quacking, we'll implement a quack subclass, a squeak subclass, and also a class that doesn't make any sound at all, which we'll call mute. For flying, we'll implement a fly with wings subclass and a fly no way subclass. Obviously, we could've added more concrete implementations to both of these. But for now this is all we need. Now that we have these behaviors in place, we can rework the duck class. To do that, we'll add two properties to the duck superclass, a reference to a fly behavior and a reference to a quack behavior. These will hold references to concrete instances of quack and fly. Notice this is a has a relationship. That is, a duck has a fly behavior and a duck has a quack behavior. We'll also add some setter methods for the fly and quack behaviors. And to avoid confusion, we'll rename the quack and file methods to perform quack and perform fly. Notice that each duck subclass now only needs to implement the display method. Now with all of the design out of the way, let's see how this works in some sample code.


-----------------------------------------------
Video: Applying the principles
-----------------------------------------------
Let's take a look at some sample code to demonstrate how we implement our new design and pull out and separate what varies in our code. For this sample code, we'll just Java. We'll be showing just a few snippets of code. To see the full working examples, download the exercise files. We'll begin by looking at the flying and quacking behaviors we've pulled out from the ducks. Recall one of the design principles we've talked about. Program to an interface, not an implementation. For both our behaviors, we'll define interfaces that all behaviors will implement. So, all fly behaviors will implement the flyBehavior interface. For example, we might implement a FlyWithWings behavior that implements regular flying and a FlyNoWay behavior that implements no flying for a duck that can't fly. Likewise all quack behaviors will implement the quack behavior interface. We might implement quacking behaviors like regular quaking for a real duck and squeaking for the rubber duck. Another quacking behavior we might implement is silence for ducks that don't quack at all like the decoy duck. One thing to notice about these behaviors is that they're completely separate from our ducks. We could use these behaviors with any code that needs duck behaviors. Now let's take a look at the code for the ducks. We'll begin with the Duck superclass. This is the superclass of all ducks in the system. It's an abstract class with an abstract method display meaning we must subclass this class with concrete ducks like mallard ducks and rubber ducks and those classes must implement the display method. Notice that the swim method works for all the concrete ducks, so we didn't need to pull that method out into separate behavior. We've got two variables in the Duck class, flyBehavior and quackBehavior. We'll use these variables to compose a duck with its flying and quacking behavior. Notice that we're using the interface types for these variables, so we can store any flying and quacking behavior in these variables. Now when we want a duck to fly, we'll call performFly. This method then delegates to the composed flyBehavior. And we do the same for quack. To get a duck to quack, we call performQuack which delegates to the composed quackBehavior. Now let's take a look at a concrete duck to see how we compose behaviors with ducks. Here we've got a MallardDuck. It extends Duck so it inherits the two properties, flyBehavior and quackBehavior as well as the performFly and performQuack methods. We're initiating the MallardDuck with the quackBehavior and the FlyWithWings behavior. We do this in the constructor so a MallardDuck is initialized when we first create it. We could instead pass in the behaviors we'd like but for this example, we're just setting the default behaviors in the constructor. Finally, we bring everything together in the MiniDuckSimulator which is where we create ducks and test their behaviors. Here we're creating a MallardDuck and then asking it to quack and fly. To get the duck to quack, we call performQuack. And recall that performQuack delegates to the quackBehavior quack method that's composed with the duck. For MallardDuck that's a regular quack behavior. So, we should see quack in the simulator. And to get the ducks to fly, we call performFly. performFly delegates to the flyBehavior fly method that's composed with the duck and for MallardDuck, that's the FlyWithWings behavior so we should see I'm flying in the simulator. Here again is our design for the ducks showing the fly behaviors and of course we have an analogous set of quack behaviors too. Rather than having our ducks rely on specific implementations of quack and fly, we're now relying on interfaces within the ducks to give us the flexibility we need. Each duck will have a flyBehavior and a quackBehavior and we won't know precisely which ones until that's set at runtime. And because we're using interfaces to specify those behaviors, we'll have the flexibility to change them as we need to and the ducks no longer need to know any details of how specific behaviors are implemented. With all that design out of the way, let's now see how this works in some sample code.


-----------------------------------------------
Video: Exploring the strategy pattern
-----------------------------------------------
We had an initial design for a duck simulator that used inheritance, but we quickly ran into problems with this design. We were having to change a lot of code in the subclasses when we added new ducks and we were duplicating code. We fixed the design by pulling out the flying and quacking behaviors and composing those behaviors with the ducks, that way each duck could use the behaviors that is right for that duck. The class design that we created for the duck simulator is an implementation of the strategy pattern. Let's take a look at the class diagram for the strategy pattern. We have an inheritance hierarchy that defines the type of the objects that need a behavior and we have a HASA relationship between those objects and their behaviors. These behaviors can be anything. Any algorithm that an object might need to perform. By moving these algorithms out from the main inheritance hierarchy, we get the benefit of being able to choose which algorithm each object gets. We can change these algorithms at runtime and if multiple objects need to use the same algorithm, we get the benefit of code reuse too. Now that you know how the strategy pattern works and what problems it solves, let's take a look at the official definition of the pattern. The strategy pattern defines a family of algorithms, encapsulates each one and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. Now this definition doesn't tell us how to implement the pattern, but it does give us a good idea of the intent of a pattern. You've seen how we implemented the pattern in the duck simulator and how that design allowed our ducks to be more flexible and made the overall system more resilient to change.


-----------------------------------------------
Video: Why HAS-A is better than IS-A
-----------------------------------------------
Let's take a step back, for a second, and look what we've done in the design of the duck simulator. One thing we've done is we're now using a HAS-A relationship to associate a duck with it's flying and quacking behavior. Remember, IS-A is an inheritance relationship. A mallard duck is a duck. And HAS-A is a relationship of composition. A mallard duck has a fly behavior. So now, instead of ducks inheriting their fly behavior, we're now composing the ducks with a fly behavior. Same with a quacking behavior. So keep in mind, that when you put two classes together, with composition, instead of inheriting behavior, an object can then instead delegate that behavior, to the composed object. We now see that composition results in a more flexible design. That let's us easily reuse flying and quacking behavior. This idea, of using composition rather than inheritance, is another important design principle. This principle says, if you have a choice, use composition rather than inheritance because typically, composition leads to a more flexible design. Let's look at another benefit in our new design, based on composition. With inheritance, in the old design, we were locked into compile time decisions about behavior. Our ducks had only one way to fly. Whether they were mallard ducks or rubber ducks. With composition, each duck has a fly behavior. Rather than limiting us to one specific implementation of behavior, we can make use of any appropriate concrete behavior, that's been implemented as a fly behavior. In fact, we can say that composition gives us a whole new family of algorithms, that we can make use of. Now if you've happily been using inheritance, in your designs, this principle may surprise you. But by using composition, we do tend to get more flexible and extensible designs than we did with inheritance. So pay close attention to each design pattern as you learn them. Because as you'll see, composition is often used as a design technique.


-----------------------------------------------
Video: Challenge: The Strategy pattern
-----------------------------------------------
Take a look at the class diagram on this slide. We have an abstract class, PhoneCameraApp, with four methods: take, edit, save and share. And, we have two concrete classes that extend PhoneCameraApp. BasicCameraApp, and CameraPlusApp. The edit method in the superclass is abstract, because each camera app will provide its own specialized editor, but the rest of the methods can be inherited by the subclasses. We get a lot of code reuse, because the taking, saving and sharing are the same across many apps. That way, the apps can implement custom editors that get the other functionality for free from the superclass. The share method in the superclass lets the user pick how they want to share the photo, and then uses that algorithm to share. Right now, the share method allows the user to share photos by text and by email. We're running into a problem, however. We keep having to open up the PhoneCameraApp class to modify the share method every time a new way to share photos crops up. You've been tasked to add another way of sharing photos to social media, but you're worried that every time you open the superclass to edit the share method code, you risk creating bugs in the system. You'd love to separate that sharing code from the rest of the PhoneCameraApp superclass so you don't risk causing a problem each time you have to edit the class. Your challenge is to redesign this class design to use the Strategy pattern, to encapsulate what's varying, that is, the sharing algorithm, and make it easy to modify the code and add new sharing algorithms without having to open up the superclass to do so. And, while you're at it, go ahead and add the social media sharing to the class design, too.


-----------------------------------------------
Video: Solution: The Strategy pattern
-----------------------------------------------
Here's our solution to the challenge. We've pulled out the different ways of sharing into a separate family of classes that implement sharing by texting, sharing by email, and sharing on social media. This is our family of algorithms. We've also added a property to the PhoneCameraApp superclass that will be composed with a strategy that the user selects. Now when the share method is called, the super class is going to delegate sharing to the user's preferred share strategy. So this design allows us to more easily add, change, and remove sharing strategies without have to modify any code in the camera app or any code in the concrete camera app classes.


***********************************************
Chapter: 3. The Adapter Pattern
***********************************************


-----------------------------------------------
Video: Understanding the adapter pattern
-----------------------------------------------
We just learned about the strategy pattern so you might have this idea that all design patterns are abstract and un-intuitive. Well, that's not the case. Let's look at another Gang of Four pattern, the Adapter pattern. Let's say that you need to plug an American style electrical cord into a European style outlet, well you can't, they have different interfaces. So to make this work, we use an adapter that adapts the European style outlet into the American style plug. It translates the outlets interface into one the American plug expects. From the perspective of the plug and the outlet, nothing has changed. They do what they've always done. Let's look at a more software oriented case. Let's say we're using a Vendor's class to achieve some goal and that class has it's own specific interface. At some point, you may want to use a different Vendor class. Perhaps you found one that's better, cheaper or faster. The only problem is that the new Vendor class has a different interface than your existing Vendor class, so how do you use it to make the system and the new Vendor class work together? Well, you create an Adapter class that implements the existing interface and then talks to the Vendor's class to carry out request. If we do our job right, the existing system and the new Vendor class will do what they've always done without the need for code changes. It's the Adapter class that will handle the work of translating the request to the new Vendor class.


-----------------------------------------------
Video: The Adapter pattern defined
-----------------------------------------------
Now that we have a conceptual idea of what Adapter does, let's take a look at the formal definition and the structure of the pattern from the Gang of Four Catalog. First, let's take a look at the definition. So, the Adapter Pattern is used to convert the interface of a class into another interface that clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces. So, this pattern's going to give us a way to have two classes work together when they have incompatible interfaces. Remember that for every pattern, we have a class diagram that explains the pattern structurally. Let's walk through the Adapter Pattern's class diagram. First, we have a client that is expecting to make a call on a target interface. In our example, the target interface would be the old vendor's interface. Next, we have an Adapter class that implements that target interface. This class is composed with an Adaptee class which the Adapter is going to make calls on. In our example, the Adaptee would be the new vendor class. So, when the client makes a call on the Adapter, using the target interface, the Adapter converts that call into one or more calls on the Adaptee. So, how does this work. Let's step through how this works at runtime. First, our client makes a request to the Adapter. In this case, by calling the request method which is part of the target interface. Next, the Adapter translates that call to the equivalent call on the Adaptee. This may take one or more calls to the Adaptee depending on the granularity of each interface. We'll see an example of this in a moment. After the Adaptee call is complete, the Adapter then returns the result, if any, to the client. The client receives the results of the call and never knows an Adapter's translating the calls to calls on the Adaptee's interface at its request.


-----------------------------------------------
Video: Using the Adapter pattern
-----------------------------------------------
Let's implement an example of the adapter pattern in code. We'll begin with a client which is a duck simulator class, a duck interface with just two methods, quack and fly, and a mallard duck that implements the duck interface. If we test the mallard duck in the simulator, that's easy. We can just pass the duck to the test duck method and the simulator implements the duck interface so the simulator already knows how to make a duck quack and fly by calling the quack and fly methods. Now what if we have a turkey and we want to use the turkey in the duck simulator? The turkey class has a slightly different interface from a duck, so we can't just plug a turkey into the duck simulator. We can't use turkeys in the duck simulator because the duck simulator test method is expecting objects that have the duck interface with the quack and fly methods. Turkeys use a different interface with the method gobble that's used to make sound instead of quack. So we can't just pass a turkey to the test method or call quack on a turkey. That won't work. So what do we do? Well we create an adapter. We'll do that by making an adapter class that converts the turkey interface to the duck interface. As you can see here, the duck simulator is the client, the duck is the target interface, the turkey adapter is the adapter, and the turkey is the adaptee. The turkey adapter implements the duck interface so that the duck simulator will know how to make the turkey quack and fly. And the turkey adapter is composed with the turkey so it can convert calls to quack and fly into gobble and fly. Here's the turkey adapter in code. The turkey adapter class implements the duck interface. So this class must implement the two methods in this interface, quack and fly. The adapter is composed with the adaptee, that is, the turkey, and we pass the turkey into the constructor and save it there. The quack method delegates to the turkey's gobble method and likewise, the fly method delegates to the turkey's fly method. Only because turkeys don't fly as well as ducks, we're going to call the turkey's fly method five times, so it flies a bit longer. So that's how the turkey adapter adapts a turkey to the duck interface. This adapter is pretty simple. We didn't have to make too many changes to make the turkeys fit into the duck simulator, although we did modify fly just a little bit. Some adapters may require multiple calls to convert from one interface to another correctly. And some adapters may return values from the adaptee to the client. Now let's bring it all together by taking another look at the client, the duck simulator. In this version, we've added code to make a wild turkey, but we can't pass a wild turkey to test duck because the test duck method expects a duck. And the wild turkey has the wrong interface. So we create a turkey adapter and pass in the wild turkey to the adapter. Notice that because the turkey adapter implements the duck interface, we can treat the turkey adapter as a duck. Then we can pass the turkey adapter to test duck to test the turkey in the simulator. As we did in the strategy pattern, we're once again using composition to get flexibility in our design. We have a client that's expecting to make calls on a class with a given interface. So we compose that client with an adapter and we compose the adapter with the adaptee. The adaptor sits in the middle of the client and the adaptee and delegates the client's calls to the adaptee. The advantage of the adapter pattern is that you can add an adapter easily without having to modify the adaptee at all and only modify the client to add the adapter. Say you have a vendor class that you can't modify and it uses a different interface than you expect, but you really need to make the vendor class work with your system. Well, the adapter pattern makes this easy.


-----------------------------------------------
Video: Challenge: The Adapter pattern
-----------------------------------------------
You've just learned how you can use the Adaptor pattern to create an adapter that adapts turkeys to ducks. In this challenge, you are going to create an adapter to adapt a drone to a duck. A drone is a small robot that can fly and is used to take photographs and videos from above. It makes a beeping sound, and it can fly by spinning its rotors and taking off. But the drone's interface is a bit different from the duck interface. So your challenge is to create an adapter for the drone so we can use the drone in the duck simulator. Here's the drone class. Can you create an adaptor class that allows it to run in the simulator?


-----------------------------------------------
Video: Solution: The Adapter pattern
-----------------------------------------------
Here's our solution for the drone adapter. Remember that the adapter needs to implement the interface of the object it's adapting to. Which in this case, is the duck. So the adapter must implement the two duck interface methods quack and fly. The drone adapter takes a drone. The quack method of the drone adapter delegates to the beep method of the drone. So the drone makes a sound. The fly method of the drone adapter is a little more complex. To fly the drone, we actually need to call two methods: spin rotors and take off. So one method in the duck interface corresponds to two method calls in the drone's interface. Now that we have the drone adapter that implements the duck interface, we can add the drone to the duck simulator. Here's how we do that. We first create a drone and then create a drone adapter, passing the drone to the adapter. What we get back is a drone adapter, but remember, it's also a duck, since the adapter implements the duck interface. So we can treat the adapter as a duck. Now we can pass the drone adapter to the test duck method and it'll work fine.


***********************************************
Chapter: 4. The Observer Pattern
***********************************************


-----------------------------------------------
Video: Understanding the Observer pattern
-----------------------------------------------
The observer pattern exemplifies the design principle of loose coupling. This principle tells us to strive for loosely coupled designs between objects that interact. What are loosely coupled objects? We say that objects are loosely coupled when they interact with one another, which makes them coupled, but they don't know a lot about each other, which makes them loosely coupled. With loose coupling, objects don't become too dependent on each other. As we'll see, this helps to keep our design more flexible. For instance, with the observer pattern, loose coupling helps us to minimize the complexity of a scenario where there are a lot of objects coming and going during a computation, and those objects need to be kept up to date on an important piece of data or a set of events. The observer pattern is one of the most commonly used patterns. You'll use it in your own code, and you'll see it used in many libraries and frameworks. And, like the adapter pattern, the observer pattern is easily explained in the form of a real world analogy. Think about your standard newspaper or magazine subscription. A published creates a newspaper, and starts publishing it. You subscribe to the newspaper, and, as long as you stay subscribed, you get each issue. You can unsubscribe at any time, and you'll stop receiving issues. Other readers can subscribe, too, and you'll all receive issues, as long as they're published, and as long as you remain subscribers. To make this example a little bit more formal, let's start with a publisher object. Any object can send a request to subscribe to the publisher object. When the request is received by the publisher, the requesting object immediately becomes a subscriber. Any object can ask to be a subscriber, meaning: we don't really care what kind of object makes the request. Obviously, there'll be objects that aren't subscribers. And any object that's currently a subscriber, can unsubscribe at any time by making a request to the publisher. The publisher typically holds some data of interest. That could be a stock quote, or weather temperature, or an entire data structure, any type of data that could be interesting. And when the data changes, all the subscribers are notified.


-----------------------------------------------
Video: The Observer pattern defined
-----------------------------------------------
Thinking about subscribers and publishers is a great way to visualize the observer pattern but if you look at the definition of the observer pattern you'll see something like this. The observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Let's step through what that means. First, the definition says that the observer pattern defines a one-to-many relationship between a set of objects. We often call these objects the subject and the dependent, which is analogous to publisher and subscriber in our example and we call it a one-to-many because if the state changes in the subject, then the many dependents are notified of that state change. All dependent means here is that these objects are dependent on the subject for data. We often call the dependent the subscriber or more commonly the observer. The subject owns the data in the sense that there's only one copy of it and by making the subject the sole owner, we end up with a design that's cleaner than many objects owning the same data. And finally, the observers, because they are observing, will get notified anytime the subject's state changes. There's a few different ways to approach the class design for the observer pattern so let's look at a common one. In this class diagram, we have a subjects interface which includes two methods that allow observers to register and to remove themselves as subscribers. It also includes a notify observers method which is responsible for notifying each observer of data changes. Concrete subjects must implement these methods. We also have an observer interface that has an update method which all concrete observers need to implement. A concrete observer can be any class that wants to implement the observer interface. The update method will be called by the subject when the subject's data changes. Now depending on your implementation, when update is called, the observers may be sent a new value as part of the update call or the observers might have to explicitly ask the subject for the new value. Now that we've seen what the class diagram looks like, let's take a look at it in code.


-----------------------------------------------
Video: Using the Observer pattern
-----------------------------------------------
Let's take a look at the Java code to implement our basic observer pattern design. We'll start with the Subject interface. This specifies the three methods the concrete subject must implement, registerObserver, to allow observers to register themselves, removeObserver, to allow observers to stop participating, and notifyObservers, which will make sure all the observers are notified if the data in the subject changes. The concrete subject, named SimpleSubject here, implements that interface, and so must implement those three methods. The SimpleSubject manages the list of observers, in this case, using an ArrayList. And, it manages the data that the observers are interested in. Here, that's just an integer, value. Observers call registerObserver to add themselves to the list of observers in the subject. And they call removeObserver to remove themselves from the list. Let's say the value in the subject changes. Perhaps, another object calls setValue to change the value. Now, the subject must notify all the observers that are participating. This is where the notifyObservers method is used. In that method, we iterate through all the observers in the list, and call update on each one, passing it the new value. All observers that want to participate, that is, get notified when the subject's data changes, must implement the Observer interface. This has one method, update. Observers can be any type. As long as they implement the Observer interface, they can participate in the pattern. A concrete observer, here, the SimpleObserver, implements that Observer interface. The observer needs a reference to the subject so it can add itself to the list of observers, by calling registerObserver. In this example, we pass the subject to the observer in the constructor, and register the observer right away. And, of course, the observer must implement that update method. This is the method that the subject will call when its data changes. The subject passes the newly updated value to the observer which saves the value and displays it.


-----------------------------------------------
Video: The Observer pattern and loose coupling
-----------------------------------------------
Let's talk about how the observable pattern helps make our design loosely coupled. We can say that the subjects and observers are loosely coupled because, while they interact, which makes them coupled, they really don't know a lot about each other, which makes them loosely coupled. If you look at the subject, the subject knows only that the observer implements a certain interface. It doesn't need to know the concrete class of the observer. In fact, any class can implement the observable interface and effectively subscribe to the subject. So what about the observer? Well, the subject doesn't know any details of the observer. All the subject knows is that it has a list of objects that implement the observable interface. And it uses that list to notify those observers when something changes. The observers are free to add themselves to the list at any time, they can also remove themselves, or even be replaced by another observer at any time. The subject just doesn't care. All it does is maintain a list and notify the objects on that list as necessary. If we ever want to add a new type of observer, we can do that without ever touching the code of the subject. As long as the observer implements the observable interface, it can participate and get notified. Any changes we make to the subject or the observers never affect the other. That's true loose coupling.


-----------------------------------------------
Video: Challenge: The Observer pattern
-----------------------------------------------
The observer pattern can be used to loosely couple objects together. Whenever you have objects that want to be notified when another object is updated. In this challenge, you'll design a weather station and various classes that are interested in the weather station's data. Including a user interface, a logger, and an alert system. The weather station has a set of sensors that are used to measure temperature, wind speed, and pressure. The user interface, logger, and alert system are all interested in the data, and want to be notified when the weather station gets new data from the sensors. Make sure your design allows for other observers to easily be added to the design. For instance, you might want your business to get notified by the weather station too, and you don't want to have to change the code in the weather station.


-----------------------------------------------
Video: Solution: The Observer pattern
-----------------------------------------------
Here's our solution to the challenge. We created a new subject interface that the weather station implements, and we added a list of observers to the weather station. We created implementations of the methods required by the subject interface to allow observers to come and go and to notify observers when the weather station's data changes. We also added a new observer interface with an update method and had each of the classes interested in the weather data implement that interface. That means each class needs to implement the update method. In addition, each class gets a reference to the weather station to access the methods in the weather station to add and remove themselves whenever they want from the list of observers.


***********************************************
Chapter: 5. The Decorator Pattern
***********************************************


-----------------------------------------------
Video: Creating chaos with inheritance
-----------------------------------------------
We're now going to explore a pattern called the decorator pattern, and to get a better understanding for this pattern we're going to start with a small example. Let's say you want to build an order system for a small coffee shop, one which serves and takes payments for beverages. The shop has four main types of beverages on the menu, each of which has a description and a cost. And to each beverage you can add a number of condiments like soy or milk or whip or mocha. Each of these condiments has a small cost which needs to be added to the cost of the coffee. Let's sketch out a design for the coffee shop's order system. We'll start with a beverage superclass which has a description field and a corresponding getter method as well as a cost method. Now let's add some subclasses like house blend, dark roast, decaf, and espresso. Note that each coffee is a beverage. In other words, we have an is-a relationship between the coffees and the beverage superclass. Also in each subclass we're overriding the cost method to calculate the cost of each particular coffee. So far this looks like a nice, simple design that we can extend to other drinks in the future. But we're forgetting that there are many variants of these beverages. Customers might want to add condiments to their order, say a decaf with soy or a dark roast with whip and mocha. One way we could take care of those variants is by adding some concrete subclasses like a house blend with steamed milk or house blend with mocha or house blend with whip and soy, and so on. And we'll need variants for a dark roast and decaf and espresso as well. You probably get the picture. This is going to be a lot of classes and we haven't even scratched the surface of all the possible combinations we can have. And what happens when we add new drinks or condiments or what if we encounter some change like when the cost of a condiment increases? That's a lot of changes to our code. Let's take a different approach. What we've done in this design is to add some properties in the superclass to track the condiment in the order. So here for each condiment we have a boolean field and a corresponding method to track if that condiment is being used in the coffee. Now let's subclass the beverage superclass again for each type of beverage. Let's see how this is going to work for an example order like a house blend with soy and whip. We first create the house blend beverage. Then to add soy and whip we can call the set soy and set whip methods respectively. After that, we can compute its cost. All this depends on the cost method in each beverage subclass, which is going to get rather complicated because we always have to test every possible condiment. But this might work so let's analyze it. Well, it looks much simpler but we have to consider that the price changes will potentially affect every single class. And if we add a new condiment we have to open up the code in the superclass and change it. Some condiments aren't appropriate for beverages and so we'll have to add complex logic in the cost method to enforce that. And we can't even handle orders like double mocha without adding some more logic in the cost method. We've got a design but it doesn't feel very flexible or maintainable at this point. The decorator pattern can help. Using the decorator pattern to solve this problem will give us a lot of flexibility in the design. We'll be able to add new drinks and condiments without having to change a lot of code. And remember how we talked about favoring composition over inheritance? The decorator pattern shows us how we can use composition to get the flexibility we want without all the complexity. We've tried two approaches to our design and neither worked very well. So let's give the decorator pattern a try. Before we dive into the pattern though we'll need to take a look at one more principle that can help us understand the problem we're trying to solve.


-----------------------------------------------
Video: Understanding the open-closed principle
-----------------------------------------------
So where do we go from here? Let's begin by getting some insight from our next design principle, the open-closed principle. This principle says that classes should be open for extension but closed for modification. What does that mean? Well, think about our current design for the coffee shop. We know in the future we'll need to support new beverage types and new condiments but that means we'll have to modify existing code, and that's exactly what we don't want. We want to leave our design open for new beverage types and condiments but closed in the sense that we don't want to touch existing code. Let's look at this principle in a little more detail. Again, the open-closed principle says that code should be open for extension but closed for modification. If we can do that, we have flexibility and maintainability because we can add new behavior but without the risk of introducing new bugs into the code we've already written. So our goal is to have designs that we can augment at any time but do it without touching existing code. This sounds like a great quality for our designs to have but it begs the question, "How do we design object systems that adhere "to the open-closed principle? "How do we allow something to be extended "that can't be modified?" Well, that's one place that design patterns can help and we already know we're going to apply the decorator pattern to this problem. But before we actually introduce the pattern let's get some hints from some things that we've already learned in this course. We'll start with inheritance. Despite its power, inheritance is not always the remedy. In fact, it can cause problems. We know that it often leads to fragile designs that can't adapt to change and we know that when we subclass we make static compile time decisions that we're stuck with, and all classes have to inherit the same behavior. As we saw with the strategy pattern, when we use composition instead we get more flexible and adaptable designs. When we use composition we can still take on new behavior but we do it by composing objects together. We can also make runtime decisions and add behavior without altering existing code. We can even go as far as adding new behavior the creator of the classes never even thought of. The end result often proves to have far fewer bugs and side effects, and overall we get more flexible designs. Now, with decorator we're going to apply composition in a totally new way that's different from the strategy pattern. Let's see how that's done.


-----------------------------------------------
Video: Extending behavior with composition
-----------------------------------------------
Before we jump into a formal definition of the Decorator pattern, let's first get a conceptual feel for how Decorator works and in particular see how we might use composition to solve our problems. To do that, let's go back to our original beverage design. Now, let's say a customer wants to order DarkRoast with Mocha and Whip. So, let's start simply by instantiating a DarkRoast object, shown here. Let's also call this object our base object, the coffee itself. Next, the customer wants Mocha, so let's create a second object, a Mocha object and wrap it around or compose it with the DarkRoast object. We'll call Mocha a Decorator and as to the hint to the structure of all this, Mocha's type is going to mirror the type of the object that it's composed with. Which, in this case, is a beverage. So, Mocha also has type beverage. Note that means it also has a cost method, so keep that in mind. Now the customer also wants Whip, so let's create a Whip object and wrap it around or compose it with the Mocha object. Like Mocha, Whip also mirrors the type of the object it decorates, which is of type beverage. So remember, that also means Whip is going to have a cost method. So, now we have an interesting set of objects composed together. Reading the object names from the inside out they also happen to match our drink order. DarkRoast, with Mocha and Whip. And as you can see, each of these objects has a cost method and is also responsible for their part of the cost. The DarkRoast knows it costs $0.99. The Mocha knows it costs $0.20. And the Whip knows a cost $0.10. So, let's see how this works. We can call cost on the outermost object Whip and then it's going to delegate that cost to the next object, which is Mocha. Which then delegates that cost to the next object which is the DarkRoast, our base coffee. But the base class is a little different. All it does is return its cost. Each time we delegate, we get a value back and then we add that cost to our own and finally return the cost. back to the caller. Now it's time to look at how this is actually achieved in classes and code. But before we do, note how flexible this design is. We can add as many condiments as we want. How about espresso with Mocha, Steamed Milk and triple Whip? How about espresso with Mocha, Steamed Milk and triple Whip?


-----------------------------------------------
Video: Understanding the decorator pattern
-----------------------------------------------
Now that you're familiar with the decorator pattern, let's take a look at the definition from the Gang of Four catalog. The decorator pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality, and we have a sense of how this design pattern can help us make a flexible design from our coffee example. As you're seeing, the formal definition of a pattern usually describes the role of the pattern, but it doesn't necessarily help us know how to implement it in our own designs. As with all design pattern definitions, we really need to look at a class diagram to get a better sense for how the pattern works. There are two important parts to the decorator pattern. There are the components which are the beverages in our example and the decorators which are the condiments in our example. Starting at the top of this diagram, you can see that we have a component class. This is an interface, or abstract class, that's implemented by the concrete components. So in our example, the component class will be the beverage, and the concrete components will be the different types of coffees. The decorators also implement the component, and that's an important piece of the decorator pattern which we'll come back to a couple of times as we look how to implement the pattern. We have a decorator class which is often an abstract class and then we have the concrete decorators that implement it, and these are the milk, the soy, and whip condiments in our example. The reason it's so important for both the concrete components and the decorators to implement the component's superclass is because we want to make sure that we can treat each class in the same way. That is, we want to be able to wrap any decorator around any of the components. For instance, in the coffee shop example, we want to be able to wrap any of the condiments around any of the coffees and then call the cost and get description methods on any of these wrapped objects. We should also be able to call cost on an unwrapped object and get the correct result. This will become a lot more clear when we look at some code, and we'll do that next.


-----------------------------------------------
Video: Using the Decorator pattern
-----------------------------------------------
Here's how we implement Starbuzz Coffee using the decorator pattern. Remember, our new design uses a common super class beverage for both the coffees and the decorators. And each decorator is composed with the beverage it is wrapping. We'll start at the top with the beverage class. This is our component super class. It implements a get description method that returns the string unknown beverage. But hopefully the concrete component classes will override this to a better description. And it specifies an abstract method cost that subclasses must implement. Now let's take a look at one of the concrete components. These are the coffees that extend the beverage class. For instance, the dark roast class extends beverage and sets the description string it inherits from beverage to dark roast coffee, so we get a good description of the coffee. Then, dark roast implements the cost method and simply returns 99 cents, which is the cost of a basic dark roast coffee with no added condiments. That takes care of the coffees, so now let's take a look at the decorators. First, we'll add that condiment decorator class. This class extends the beverage class, meaning it inherits the get description method. But we're going to override the get description method with an abstract method, so we force all concrete decorators to implement that method. Because condiment decorator is abstract, it does not need to implement cost. But any concrete decorators will need to do that because cost is abstract in beverage. Now let's implement some decorators. Each condiment that can be added to a coffee is implemented as a decorator class. Here's an example of a condiment, the whip condiment. It extends condiment decorator, so it must implement the get description method and the cost method. Each decorator is composed with the beverage that it's wrapping. And the type of the beverage is beverage, meaning the super class of both the concrete beverages, that is the coffees, as well as the decorators. That means that we can wrap a condiment around either a basic coffee or a decorated coffee. We pass the beverage that we want the condiment to wrap into the constructor class, and store it. Then in get description, we first get the description of the beverage we're wrapping, and then add whip to that. So if we're wrapping a dark roast, we'll get the string dark roast coffee from the beverage and add on, comma whip. Finally, to get the cost, we first get the cost of the beverage we're wrapping, and then add 10 cents to that. Again, if we're wrapping a dark roast coffee, we'll get 99 cents and we'll add 10 cents and return the total cost of $1.09 for a dark roast with whip. Let's look at an example of how to put everything together. In the main Starbuzz Coffee class, we've received an order of a double mocha dark roast with whip. We first create the dark roast coffee. We store that beverage in a variable of type beverage. Next, we pass that beverage to the mocha constructor to create a mocha decorator. It's important to notice here that we also store this in the variable of type beverage. That's so we can continue to decorate the beverage. Remember, that decorators are composed with beverages. Next, we do that again to get a double mocha decorator with a dark roast. Finally, we pass that beverage to the whip constructor. And we get back whip decorated beverage. At this point, we have a dark roast coffee, decorated by two mochas and a whip. Now it's time to compute the final description and cost. We call get description on the outermost decorator, the whip decorator. Remember that whip delegates to the beverage it's wrapping to get the description, and then adds on comma whip. And the mochas do the same. And finally, the inner mocha delegates to the dark roast and gets back a string, dark roast coffee. This is where the delegation stops, so the resulting string propagates back out and we get dark roast coffee, comma mocha, comma mocha, comma whip. The same thing happens when we compute the cost. Each decorator delegates to the beverage it's wrapping to get the cost. And then adds on the cost of the decorator, so the result we get back is the total cost of the beverage. By using composition, we get flexibility in how we add condiments or capabilities to our beverages. And by using a common beverage super type with inheritance we get the type structure we need to treat coffees and decorated coffees both as beverages. So we can decorate beverages multiple times and call get description and cost on basic coffees or decorated coffees.


-----------------------------------------------
Video: Challenge: The Decorator pattern
-----------------------------------------------
Let's say you want to start up a pizza store, offering both thick and thin crust pizzas. You'd like to offer a variety of toppings for the pizza that can be combined in any way the customer wants, and you'd like to be able to easily add and remove toppings from the menu over time as you determine what your customers like. You'll need to be able to get a description of the pizza to hand to the chef and a total cost of the pizza to charge the customer for their order. Your challenge is to design a system for the pizza store using the Decorator pattern. Have fun, and feel free to get a snack while you're working on the challenge just in case you're hungry.


-----------------------------------------------
Video: Solution: The Decorator pattern
-----------------------------------------------
Here's our solution for creating pizzas with the decorator pattern. In this solution, we've closely followed the decorator pattern structure. First, we define a Pizza class that has a getDescription method and an abstract cost method. Then we added ThinCrustPizza and ThickCrustPizza concrete subclasses, which both extend the Pizza class. We also created a ToppingDecorator class that, again, following the structure of the decorator pattern, extends the Pizza abstract class. Note that ToppingDecorator has a property Pizza and an abstract method getDescription. Extending the ToppingDecorator, we've created classes Cheese, Olives, and Peppers for our toppings. We'll pass in the pizza the toppings are decorating and the constructor, and store the pizza in the Pizza variable that's inherited from the ToppingDecorator class. The cost method in the pizza classes return the cost of the basic thin or thick crust pizza, while the cost method in the toppings classes returns the cost of the pizza plus the topping. This works just like in our coffee example. Remember that with decorator, we use inheritance to get a common supertype for pizzas and decorated pizzas and we use composition to add topping decorators to our pizza.


***********************************************
Chapter: 6. The Iterator Pattern
***********************************************


-----------------------------------------------
Video: Encapsulating iteration
-----------------------------------------------
We have many ways to store collections of objects in data structures. For example, most modern programming languages provide arrays. If you're using Java, you could store menu items for a menu in an array like this. Most languages provide additional structures for storing collections of objects like lists, dictionaries and sets. For example, Java provides an ArrayList, which is a lot like an array, but has some list like capabilities too. Here we're storing our menu items in an ArrayList. Simple enough, but what if we need to write code that operates over several of these collection types? Let's say you want to write a print method to print any menu. To print a menu, we need to iterate over the collection that's storing the menu items. If you're using an array to store your menu items, you'll write code like this. Now if you decide to change the representation of menus from an array to an ArrayList, you end up rewriting all that code to print the menus because the code depends on the concrete type that we're using for the collection. We need different code to iterate through and print the menu items when they're stored in an ArrayList, like they are here. Is there a way that we can avoid rewriting the iteration code if we change our collection type? Let's use the same tactic we've been using and separate out what varies and encapsulate it. What's varying here? Our iteration. But how do we encapsulate iteration? That's what the iteration pattern helps us do.


-----------------------------------------------
Video: Understanding the Iterator pattern
-----------------------------------------------
As we've seen, we've got two menus with two different implementations. One uses an Array, and the other uses an ArrayList. That means that the class responsible for printing the menus, the cafe, needs to use two different methods of entering through the menu items. So the two menus are exposing the details of how they're implemented to the cafe, which means that the cafe is dependent on those implementations. If someone decides to change the implementation of a menu, or say, add another type of menu, or say, add another type of menu, that will require code changes to the cafe. that will require code changes to the cafe. We can reduce the dependency between the cafe We can reduce the dependency between the cafe and the menu implementations by using the iterator pattern. and the menu implementations by using the iterator pattern. Here's the definition for iterator pattern. Here's the definition for iterator pattern. The iterator pattern provides a way The iterator pattern provides a way to access the elements of an aggregate object sequentially to access the elements of an aggregate object sequentially without exposing its underlying representation. without exposing its underlying representation. So this pattern gives you a way to access the elements of an aggregate object, and to do it sequentially, and it does it without exposing that underlying representation. that underlying representation. So that sounds like what we need for the cafe. Let's step through that. Let's step through that. First, what is an aggregate object? First, what is an aggregate object? Well that's just a collection of objects, like an Array, Well that's just a collection of objects, like an Array, or in Java, the Collection classes, like an ArrayList. or in Java, the Collection classes, like an ArrayList. But, aggregate objects aren't limited to Java. But, aggregate objects aren't limited to Java. You'll find aggregate objects like list, and sets, and maps, and dictionaries in most modern languages. and maps, and dictionaries in most modern languages. So we know what an aggregate object is, So we know what an aggregate object is, but we need to be able to access its elements but we need to be able to access its elements without having to know exactly without having to know exactly how the aggregate is implemented. how the aggregate is implemented. In other words, we don't need to know In other words, we don't need to know if a menu is implemented as an Array, or an ArrayList, if a menu is implemented as an Array, or an ArrayList, or another aggregate type, we just want or another aggregate type, we just want to access its elements, and do it in a sequential manner. to access its elements, and do it in a sequential manner. To accomplish this, To accomplish this, the aggregate object provides an iterator object. the aggregate object provides an iterator object. The iterator object knows how to iterate over the aggregate, The iterator object knows how to iterate over the aggregate, but the client, that is the object using the iterator, but the client, that is the object using the iterator, which is the cafe in our example, which is the cafe in our example, doesn't have to know the details. doesn't have to know the details. It just has to know how to ask for, It just has to know how to ask for, and how to use that iterator. and how to use that iterator. So, to iterate over an aggregate object, So, to iterate over an aggregate object, using iterator pattern, the client asks using iterator pattern, the client asks an aggregate object first for its iterator, an aggregate object first for its iterator, and then it uses it to iterate through each of its elements. and then it uses it to iterate through each of its elements. Because every aggregate object Because every aggregate object provides the same kind of iterator, provides the same kind of iterator, the client can use the same code to iterate the client can use the same code to iterate over any kind of aggregate object. over any kind of aggregate object.


-----------------------------------------------
Video: Using the Iterator pattern
-----------------------------------------------
Let's take a look at the class diagram for the iterator pattern and then we'll see how to implement it for the menus. In our example, the aggregate object is a menu which uses an array list or an array to store the menu items. We have an aggregate interface and a concrete aggregate class that implements that interface, providing a method, create iterator, that creates and returns an iterator object. The client stores that iterator and then, when it needs to iterate over the items in the aggregate object, it can use the methods defined by the iterator interface to do so. The hasNext method figures out if there are more items to iterate over and the next method just returns the next item. Here's how we'll design our menus example to use the iterator pattern. Our aggregate object will be the menu. We'll add a menu interface that defines one method, create iterator, and both the pancake house menu and the diner menu will implement that menu interface. When the cafe wants to iterate over the menu items it will ask the menus for their iterators using the create iterator method. The cafe doesn't care about how the iterators work under the covers because now, it can use the same interface to iterate over both menus. The iterators that the two menus create both implement the iterator interface, which specifies the two methods, hasNext and next, so the specific implementations of how to iterate over the menu items for each type of menu are encapsulated in the two iterators, one for each type of menu. Right now, the iteration responsibilities are with the cafe. The cafe has to know the details of how each menu is stored, so it can iterate one way through the menu using an array and another way through the menu using the array list. We can remove this responsibility from the cafe using the iterator pattern. By building iterators for the two menus, we'll move the details of the iteration to the iterators and out of the cafe. Now, each menu will implement a menu interface that specifies a create iterator method. This method creates an iterator for that menu and returns it. Let's take a look at the iterator for the diner menu. This is the menu that uses an array to store menu items. The iterator implements the iterator interface, which specifies a common API for iterating through a collection of items, the next and hasNext methods. The next method gets the next item from the array and returns it. The hasNext method checks to see if there's another item in the array and returns true or false. Now the cafe can use one method, print menu, to iterate through any menu it uses and every menu implements the menu interface. So we can get a menu's iterator and pass it to a new print menu method and in that method, we use the iterator interface, that is the next and hasNext methods, to iterate through the menu items. By moving the responsibility of iteration to the iterators, we've made the cafe more flexible. Now the cafe can work with any kind of menu, as long as that menu implements the menu interface and has an iterator that knows how to iterate through the menu items collection.


-----------------------------------------------
Video: Using built-in iterators
-----------------------------------------------
Java offers a built-in iterator interface. Java.util.iterator. We can use this interface instead of building our own if we want to. The java.util.iterator interface acts both as an interface that your own iterator classes can implement as well as the type of the Java collection classes built-in iterators. Classes like ArrayList, Vector and LinkedList all have an iterator method that returns a ready built iterator with a type java.util.iterator. Now if you're asking, well, why did we build our own iterator for the diner menu? Well, we wanted you to see how to create an iterator from scratch, but now that you know how to do that, you should also know how to use the built-in iterator interface and the collection iterators. It's worth noting that Java arrays don't have built-in iterators in the same way the collection classes do. So building an iterator for an array or custom collection is a good way to see how the iterator pattern works. In our cafe example, the Pancake House menu stores menu items in an ArrayList, so instead of creating our own iterator for this menu, we can simply get the iterator for the ArrayList and use that. 


-----------------------------------------------
Video: The single responsibility principle
-----------------------------------------------
Let's think about responsibility for a minute. One thing to remember about giving responsibilities to a class, is that for every additional responsibility, a class has another reason it might have to change in the future. So by giving a class multiple responsibilities we give the class more than one reason it might have to change. And we know we want to minimize change where we can. This brings us to another design principle. The Single Responsibility Principle. Which says that a class should have only one reason to change. Adhering to this principle minimizes the chances that a class is going to need to change in the future. Now let's think about collections and iterators. If we allow a class to handle both the responsibilities of managing a collection, and managing the iteration, then we have two areas of potential change. That's why we separate the iteration responsibility into its own class. Now be careful. We're humans, and in general, our brains like to combine things and not separate them. We look for commonality, rather than finding differences. And this is where you need to be diligent, and to examine your class designs, to look for multiple responsibilities. If you see more than one, well then, you need to examine those areas and see if you find the potential for change there. If you do, then it's probably a good idea to separate them.


-----------------------------------------------
Video: The iterator pattern as language feature
-----------------------------------------------
The iterator pattern is one of those patterns that is so useful it's become built-in to languages as language features. Languages provide built-in iterators as we saw with Java collections and they use iterators in language statements too. These statements hide the iterator pattern and it's iterators behind the scenes and make it easy to iterate through collections of values. Java, Python and JavaScript all have statements that use the iterator pattern behind the scenes. Java's enhanced for statement is designed for iteration through collections and arrays. So this code will work whether animals is an ArrayList of animal objects or an array of animal objects. Python's for/in statement can be used with any iterable aggregate object such as string, list and tuple and JavaScript's for/of statement can be used with strings, arrays, maps and sets. All of which are iterable objects meaning there are iterators associated with these objects that the for/of statement can use to iterate. Just as with the cafe example we went through in detail, these statements move the responsibility of the iteration away from the main code that's using the aggregate objects. In the case of built-in statements, the implementation details are already taken care of so all you have to do is use the statement to take advantage of the iterator pattern.


-----------------------------------------------
Video: Challenge: The Iterator pattern
-----------------------------------------------
It's time for another challenge. For the iterator pattern, we're going to try something a little different. For this challenge, you'll need to do a little research before writing code. Most modern programming languages incorporate the iterator pattern. So it's valuable to learn how the iterator pattern is used in languages that are important to you. So pick one of your favorite programming languages. In that language, identify how the Iterator pattern is used to iterate over collections of objects. You might have to do a little bit of research to figure out which types are iterable, and what statements are used to iterate over those types of objects. After you've done your research, implement a small code example to iterate through an aggregate object like an array or a list in the language of your choice.


-----------------------------------------------
Video: Solution: The Iterator pattern
-----------------------------------------------
For our challenge solution, we chose the Swift programming language. And Swift aggregate objects, like arrays and sets and dictionaries, are all sequences, and they all provide built-in iterators. You can use the for in statement, like we're doing here in the short example, that iterates over an array of animals. Or you can use the underlying iterator supplied by the sequence and use that iterator's interface to iterate. However, most of the time, you'll just use the for in statement.


***********************************************
Chapter: 7. The Factory Patterns
***********************************************


-----------------------------------------------
Video: The need for factory patterns
-----------------------------------------------
We've talked about programming to interfaces, not implementations. When we program to an implementation, we get locked into concrete types, and more importantly, our code will require changes if our set of concrete types ever gets extended. It might seem interesting that by using the new operator, we're forcing ourselves into a concrete implementation. Like here where we assign duck to a new mallard duck. We'd like to use an interface like duck as the type for the variable, but ultimately, we have to create a concrete type, like mallard duck, to create a duck object. Quite often, we end up writing code like this. Here we have a duck variable and we use conditional logic to pick the concrete type of the duck. For instance, if we're at a picnic, we create a mallard duck, and if we're hunting, then we create a decoy duck, and if this is a bathtub, we create a rubber duck. With this code, we're making runtime decisions about which class to instantiate. When we see code like this, we know that if requirements change and we want to add new duck types, we're going to have to open up this code and change it and that violates the open closed principle. We might also end up writing this same code in several places in this application, making the situation even worse. So what do we do? As usual, let's look at what varies and encapsulate it. Let's say we have a pizza restaurant. We make the pizzas by calling a method to order a pizza. That method takes the string type, and depending on the value of that type, whether it's cheese, Greek, or pepperoni, we create a pizza of that type and then we prepare it, cook it, and return it to the customer. Of course, the restaurant is going to continue to grow and change over time, adding and removing pizzas. So in our second version, we've removed the Greek pizza and we've added a veggie. Clearly, our pizza types are getting in the way of closing this code for modification. As long as the pizza restaurant is in business, this code is going to be open, so let's think about how we can encapsulate the code to create pizzas and move that code out into a separate class. We're going to take the pizza creation code, encapsulate it, separate it, and put it in an object called a factory. Why a factory? Because this is an object whose sole responsibility is creating pizzas. It's a pizza factory. To do that, we'll take this conditional code for creating pizzas, pull it out, and put it in a simple pizza factory class with a method name, create pizza. Any time we want a pizza, we'll call this method and pass it a type. And the method will make the pizza for us and return and object that implements the pizza interface. All this creation code is now in one place, nicely separated from the rest of the restaurant code. Let's integrate this back into the original restaurant code. To do that, we'll assume we've created a factory object already. We'll call the method create pizza to create the pizza, passing it the type variable. The order pizza method no longer has to worry about the concrete type of the pizza. It could be a veggie pizza, a cheese pizza, or a pizza we haven't even heard of yet. Because we know that whatever type gets returned from the factory, it implements the pizza interface and that's all we care about. We call this design the simple factory pattern and it's a very common way to deal with object creation. Here's the class diagram that represents a simple factory for pizzas. We start with a client of the factory, the pizza restaurant, which we'll call Pizza Store. And then we have our factory. The factory is the only place the concrete types of pizzas are known, and then we have a product the factory makes, our pizzas. And there could be many concrete types of those. Now to generalize this a bit, here's the same diagram without the pizzas. Here we have a client, a factory, and a set of products that implement a product interface. The simple factory pattern is pretty simple, but it's a common way to deal with creating objects, and it's the first step to understanding some of the more powerful factory patterns.


-----------------------------------------------
Video: The Factory Method pattern
-----------------------------------------------
We just used a simple factory to create our pizza store. Notice that the Simple factory allows us to decouple the process of creating objects from the clients that use those objects. In our case, we used a simple factory to create pizzas so that the pizza store didn't have to worry about the details of the various pizza types. Instead it could focus on the pizza preparation and delivery. This approach works well. But what happens if we have multiple store franchises? Let's say we have two pizza stores and one wants to make New York-style pizza and the other one wants to make Chicago-style pizza. Now we're in the situation where we're going to need to use two different factories to make two different styles of pizza. We know the downside of that, code duplication. It's also presumably our process. That is all that code that isn't changing that has made it successful and we want to keep that common to both stores while giving the stores the flexibility to make the kinds of pizzas that are appropriate for the local markets. The simply factory just isn't going to work for that. Let's step back. We need for our store to share the same time-tested algorithm for making pizzas but to have the flexibility to create different types of pizza objects. In our case, one that creates New York-style pizzas while the other creates Chicago-style pizzas. To create store franchises, we'll change our design to use the factory method pattern. This pattern defines an interface for creating an objet but lets subclasses decide which classes to instantiate. Factory method lets a class defer instantiation to the subclasses. Let's see what this means by taking a look at a new design for the pizza store. First, we're going to change the PizzaStore class so it's an abstract class. All the pizza stores in their franchise will extend this class and because we want all stores to use the same method of preparing pizzas, the PizzaStore abstract class will implement the orderPizza method. This is the shared code that is used by all the stores to prepare the pizza. Our New York pizza store and the Chicago pizza store are now going to subclass the PizzaStore and implement their own createPizza methods. That way each store gets to decide what kinds of pizzas to make. The New York-style pizza store will make New York-style pizzas while the Chicago pizza store will make Chicago-style pizzas. This is what is meant in the factory method pattern definition when we say that the factory method lets a class defer instantiation to subclasses. Here the abstract pizza store is deferring instantiation of the concrete pizzas to the individual pizza stores that extend it. Our pizza class is basically the same. But now we're going to have many more types of pizzas. A set of pizzas for the New York-style pizza store and a set of pizzas for the Chicago-style pizza store. The New York-style pizza store will be responsible for creating the New York-style pizzas and the Chicago-style pizza store will be responsible for creating the Chicago-style pizzas. Now that we've seen how this works conceptually, let's look at some code to further our understanding.


-----------------------------------------------
Video: Using the Factory Method pattern
-----------------------------------------------
To create a pizza, we first need to instantiate the kind of store we want. Imagine you're choosing between walking into a New York-style pizza store, or a Chicago-style pizza store. Once we're in the store, we can order a pizza. Remember, this method is implemented by the abstract class, PizzaStore. No matter which pizza store we're in when we make an order, we're guaranteed to get the same, brilliant pizza-making algorithm to produce quality pizzas. The first step in the orderPizza algorithm is to create the pizza. The createPizza method is implemented by the individual stores. So, in a New York pizza store, we'll get the method implemented by that store. We pass the type of pizza along to the createPizza method. This method creates the right kind of pizza based on the type. And once it's returned to the orderPizza method in the store, the orderPizza method can prepare the pizza for the customer. Let's get a better sense of how the Factory Method pattern defers instantiation to subclasses. Remember that the pizza store is defining the orderPizza method, but leaving the createPizza method to be implemented by the subclasses. Let's see how this works in practice. Here's the code for the New York pizza store. This class implements the createPizza method, and based on the type of pizza passed into the method, creates the right kind of New York-style pizza. Likewise, the Chicago-style pizza store creates the right kind of Chicago-style pizza in the createPizza method. Both the New York store and the Chicago store extend the PizzaStore, which is where the orderPizza method is implemented. This method is inherited by each concrete pizza store. So when we call createPizza from the orderPizza method, we use the createPizza method that's in the concrete store. So, if we create a New York pizza store, we'll use the createPizza method in that class and get New York-style pizzas. And if we create a Chicago pizza store, we'll use the createPizza method in that class and get Chicago-style pizzas. So it's the concrete stores, that is, the subclasses that get to decide which type of pizza to make.


-----------------------------------------------
Video: Challenge: The simple Factory pattern
-----------------------------------------------
Take a look at this design. We have a ZoneFactory whose job is to create the right kind of time zone for our calendar app. Let's say you're instantiating a calendar for a user in the Pacific Time Zone. Then you'd ask the ZoneFactory to create the appropriate zone for the calendar to use. The time zones the Factory knows how to create are the U.S. time zones, Eastern Time, Central Time, Mountain Time, and Pacific Time, and each has a corresponding zoneid. The zone displayName is just the name of the time zone, like USPacific, and the offset is the numeric offset of the time zone from GMT which is minus five for Eastern, minus six for Central, minus seven for Mountain, and minus eight for Pacific. Your challenge is to write the code for the Zone classes, that is the Zone class and its subclasses and the ZoneFactory that will create the correct zone based on the zone id that you pass to its createZone method, and here's a hint. For this design, we're using the simple Factory pattern.


-----------------------------------------------
Video: Solution: The simple Factory pattern
-----------------------------------------------
Here's our challenge solution. We created a Zone class with a String display name and an integer offset. We also implemented the two getter methods for those fields. Each specific zone subclass extends zone and sets the appropriate display name and offset for each specific time zone. And here's the Zone Factory class. This factory has one method, create zone, which takes the string zone ID. We test the zone ID for each of the possible zone classes we can create, and create the appropriate concrete zone class and return that. The calendar will use the factory to create a zone, and then use that zone class to display the calendar appointments. The calendar doesn't have to worry about the specific type of the zone, and if we want to add support for more time zones, we can do that by updating the Zone Factory without having to modify any calendar code.


***********************************************
Chapter: Conclusion
***********************************************


-----------------------------------------------
Video: Applying patterns
-----------------------------------------------
After a long discussion of design patterns, it's easy to see design patterns can be powerful. And it's easy to see all kinds of ways you can use design patterns in your current and future designs. Developers love to create beautiful architectures that are ready to take on change from any direction. But is that how we should think about patterns? Don't think of patterns as a magic bullet. When you see the need for one, you'll sleep well knowing many developers have been there before and solved the problem using similar techniques. However, patterns aren't the solution to every problem. - So how do you know which patterns to use? If you've got a good knowledge of patterns, you may know of a pattern that is a good match. Otherwise, review patterns that look like they might solve the problem. Once you've found a pattern that appears to be a good match, make sure it has a set of consequences you can live with and study its effects on the rest of your design. If everything looks good, go for it. Use patterns when you have a practical need to support change in a design today. However, if your problem is only hypothetical, don't add the pattern. It's only going to add complexity to your system, and you might never need it. - Remember, always solve things in the simplest way you can. Your goal should always be simplicity, not how can I apply a pattern to this problem? Don't feel like you aren't a sophisticated developer if you don't use a pattern to solve a problem. Other developers will appreciate and admire the simplicity of your design. That said, sometimes the best way to keep your design simple and flexible is to use a pattern. - As we've discussed, object oriented design does not always come easy, even for experts. And design principles and patterns give us some useful tools that help us create software that is truly more flexible and resilient to change.


-----------------------------------------------
Video: Where to go from here
-----------------------------------------------
Here are a couple of resources for taking your study further. Starting with the definitive book by the gang of four. This is a catalog of the 23 original design patterns. You'll find each pattern outlined in the catalog including each pattern's historical examples in C++ and Smalltalk. As we've said, this book is very much a catalog and not particularly focused on learning patterns and principles. To remedy that, we'd also like to suggest our book, Head First Design Patterns, published by O'Reilly Media. Our book is a learners guide to design patterns and design principles. The book has become the go-to book for learning about design patterns. You'll get a deep introduction to the gang of four patterns and many related design principles. Of course, you'll also find many online resources for patterns with a good internet search. In this course, we've just scratched the surface of design patterns and to truly take advantage of design patterns, you'll want to build up your repertoire of design patterns and principles and remember, even if you aren't using a pattern, just knowing the principles will go a long way towards improving your design skills. To continue your journey, understanding the remaining gang of four patterns is a great place to start and from there, you'll be in good shape to tackle design patterns from other domains like enterprise patterns and distributed computing patterns. We hope you enjoyed this course and you're inspired to go out and write some great software.

